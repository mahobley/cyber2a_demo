import { promises as fs } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '..');
const metadataRoot = path.join(projectRoot, 'metadata');

const JSON_SPACING = 2;

async function readJsonFiles(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const records = [];

  for (const entry of entries) {
    if (!entry.isFile() || !entry.name.endsWith('.json')) continue;
    const fullPath = path.join(dir, entry.name);
    const contents = await fs.readFile(fullPath, 'utf8');
    try {
      const data = JSON.parse(contents);
      records.push(data);
    } catch (error) {
      throw new Error(`Failed to parse JSON in ${fullPath}: ${error.message}`);
    }
  }

  return records;
}

function sortByKey(list, key) {
  return [...list].sort((a, b) => {
    const left = (a?.[key] ?? '').toString().toLowerCase();
    const right = (b?.[key] ?? '').toString().toLowerCase();
    return left.localeCompare(right);
  });
}

function deepClone(value) {
  return JSON.parse(JSON.stringify(value));
}

function ensureUniqueIds(records, type) {
  const seen = new Set();
  for (const record of records) {
    if (!record.id) {
      throw new Error(`Missing id in ${type} metadata: ${JSON.stringify(record)}`);
    }
    if (seen.has(record.id)) {
      throw new Error(`Duplicate id "${record.id}" found in ${type} metadata.`);
    }
    seen.add(record.id);
  }
}

function buildDatasetMap(datasetRecords) {
  ensureUniqueIds(datasetRecords, 'dataset');
  const map = new Map();
  datasetRecords.forEach((dataset) => {
    map.set(dataset.id, dataset);
  });
  return map;
}

function buildCourseMap(courseRecords) {
  ensureUniqueIds(courseRecords, 'course');
  const map = new Map();
  courseRecords.forEach((course) => {
    map.set(course.id, course);
  });
  return map;
}

function resolveDatasets(datasetIds = [], datasetMap) {
  return datasetIds.map((id) => {
    if (!datasetMap.has(id)) {
      throw new Error(`Lesson references unknown dataset id "${id}".`);
    }
    return deepClone(datasetMap.get(id));
  });
}

function resolveCourseTitle(courseId, courseMap) {
  if (!courseId) return null;
  const course = courseMap.get(courseId);
  if (!course) {
    throw new Error(`Lesson references unknown course id "${courseId}".`);
  }
  return course.title ?? null;
}

function buildLessonMetadata(lessonRecords, datasetMap, courseMap) {
  ensureUniqueIds(lessonRecords, 'lesson');
  return sortByKey(lessonRecords, 'id').map((lesson) => {
    const {
      datasetIds = [],
      courseId = null,
      syllabus,
      id,
      ...rest
    } = lesson;

    const datasets = resolveDatasets(datasetIds, datasetMap);
    const courseTitle = syllabus ?? resolveCourseTitle(courseId, courseMap);

    return {
      ...rest,
      id,
      courseId,
      syllabus: courseTitle,
      datasets,
    };
  });
}

async function writeLessonsDataFile({ lessons, datasets, courses }) {
  const targetPath = path.join(projectRoot, 'lessons-data.js');
  const content = `/**\n * Auto-generated by scripts/build-metadata.mjs.\n * Do not edit this file directly.\n */\nexport const lessonMetadata = ${JSON.stringify(lessons, null, JSON_SPACING)};\n\nexport const datasetCatalog = ${JSON.stringify(datasets, null, JSON_SPACING)};\n\nexport const courseCatalog = ${JSON.stringify(courses, null, JSON_SPACING)};\n`;
  await fs.writeFile(targetPath, content, 'utf8');
}

async function writeManifest(manifest) {
  const targetPath = path.join(metadataRoot, 'manifest.json');
  await fs.writeFile(
    targetPath,
    JSON.stringify(manifest, null, JSON_SPACING),
    'utf8'
  );
}

async function main() {
  const datasetDir = path.join(metadataRoot, 'datasets');
  const courseDir = path.join(metadataRoot, 'courses');
  const lessonDir = path.join(metadataRoot, 'lessons');

  const [datasetRecords, courseRecords, lessonRecords] = await Promise.all([
    readJsonFiles(datasetDir),
    readJsonFiles(courseDir),
    readJsonFiles(lessonDir),
  ]);

  const datasets = sortByKey(datasetRecords, 'name');
  const courses = sortByKey(courseRecords, 'title');
  const datasetMap = buildDatasetMap(datasets);
  const courseMap = buildCourseMap(courses);
  const lessons = buildLessonMetadata(lessonRecords, datasetMap, courseMap);

  await writeLessonsDataFile({ lessons, datasets, courses });
  await writeManifest({
    generatedAt: new Date().toISOString(),
    lessonCount: lessons.length,
    datasetCount: datasets.length,
    courseCount: courses.length,
    lessons: lessons.map((lesson) => lesson.id),
    datasets: datasets.map((dataset) => dataset.id),
    courses: courses.map((course) => course.id),
  });
}

main().catch((error) => {
  console.error('[metadata builder] Failed to build metadata');
  console.error(error);
  process.exitCode = 1;
});
